<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>How does &#39;kubectl exec&#39; work? &middot; Erkan Erol</title>

  
  <link rel="stylesheet" href="https://erkanerol.github.io/css/poole.css">
  <link rel="stylesheet" href="https://erkanerol.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://erkanerol.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://erkanerol.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://erkanerol.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://erkanerol.github.io/css/highlight/monokai.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://erkanerol.github.io/touch-icon-144-precomposed.png">
  <link href="https://erkanerol.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="Erkan Erol&#39;s Blog">
  <meta name="keywords" content="Software,k8s,Kubernetes">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-57796113-2', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">  
      
        <img src="https://www.gravatar.com/avatar/321108fd00753fd95baeddbc3abc8a76?s=200"
             alt="gravatar" title="Erkan Erol">
      
      <h1>Erkan Erol</h1>
      
    </div>


    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="https://erkanerol.github.io/">
        
        Blog</a>
      </li>
      
      <li class="sidebar-nav-item">
         
        <a href="https://erkanerol.github.io/categories/tr/">Turkish</a>
      </li>
      
      <li class="sidebar-nav-item">
         
        <a href="https://erkanerol.github.io/categories/en/">English</a>
      </li>
      
      <li class="sidebar-nav-item">
        
        <a href="https://erkanerol.github.io/post/about/">About me</a>
      </li>
      

      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/erkanerol"><i class="fa fa-github-square fa-2x"></i></a>
      
      <a href="http://stackoverflow.com/users/2900777/erkan-erol"><i class="fa fa-stack-overflow fa-2x"></i></a>
      <a href="https://www.linkedin.com/in/erkan-erol-26488b91?"><i class="fa fa-linkedin-square fa-2x"></i></a>
      
      
      <a href="https://twitter.com/erkan_erol_"><i class="fa fa-twitter-square fa-2x"></i></a>
      
      <a href="https://erkanerol.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-2x"></i></a>
      </li>
    </ul>

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">How does &#39;kubectl exec&#39; work?</h1>
    <span class="post-date">Aug 25, 2019 &middot; <a href="https://erkanerol.github.io/post/how-kubectl-exec-works/#disqus_thread">Comments</a>
    
    <br/>
    <a class="label" href="https://erkanerol.github.io/categories/software">Software</a><a class="label" href="https://erkanerol.github.io/categories/k8s">k8s</a><a class="label" href="https://erkanerol.github.io/categories/en">EN</a>
    </span>
    <p>Last Friday, one of my colleagues approached me and asked a question about how to exec a command in a pod with client-go. I didn&rsquo;t know the answer and I noticed that I had never thought about the mechanism in &ldquo;kubectl exec&rdquo;. I had some ideas about how it should be, but I wasn&rsquo;t 100% sure. I noted the topic to check again and I have learnt a lot after reading some blogs, docs and source codes. In this blog post, I am going to share my understanding and findings.</p>

<blockquote>
<p>Please ping me if there is something wrong. <a href="https://twitter.com/erkan_erol_">https://twitter.com/erkan_erol_</a></p>
</blockquote>

<p><br><br></p>

<h2 id="setup">Setup</h2>

<p>I cloned <a href="https://github.com/ecomm-integration-ballerina/kubernetes-cluster">https://github.com/ecomm-integration-ballerina/kubernetes-cluster</a> in order to create a k8s cluster in my MacBook. I fixed IP addresses of the nodes in kubelet configurations since the default configuration didn&rsquo;t let me run <code>kubectl exec</code>. You can find the root cause <a href="https://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706">here</a>.</p>

<ul>
<li>Any machine = my MacBook</li>
<li>IP of master node = 192.168.205.10</li>
<li>IP of worker node = 192.168.205.11</li>
<li>API server port = 6443</li>
</ul>

<p><br><br></p>

<h2 id="components">Components</h2>

<p><img src="/img/kubectl-exec/components.png" title="Components"/></p>

<ul>
<li><p><strong><em>kubectl exec process:</em></strong> When we run &ldquo;kubectl exec &hellip;&rdquo; in a machine, a process starts. You can run it in any machine which has an access to k8s api server.</p></li>

<li><p><strong><em><a href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver">api server</a>:</em></strong> Component on the master that exposes the Kubernetes API. It is the front-end for the Kubernetes control plane.</p></li>

<li><p><strong><em><a href="https://kubernetes.io/docs/concepts/overview/components/#kubelet">kubelet</a>:</em></strong> An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.</p></li>

<li><p><strong><em><a href="https://kubernetes.io/docs/concepts/overview/components/#container-runtime">container runtime</a>:</em></strong> The software that is responsible for running containers. Examples: docker, cri-o, containerd&hellip;</p></li>

<li><p><strong><em>kernel:</em></strong> kernel of the OS in the worker node which is responsible to manage processes.</p></li>

<li><p><strong><em>target container:</em></strong> A container which is a part of a pod and which is running on one of the worker nodes.</p></li>
</ul>

<p><br><br></p>

<h2 id="findings">Findings</h2>

<h3 id="1-activities-in-client-side">1. Activities in Client Side</h3>

<ul>
<li><p>Create a pod in default namespace</p>

<pre><code>// any machine
$ kubectl run exec-test-nginx --image=nginx
</code></pre></li>

<li><p>Then run an exec command and <code>sleep 5000</code> to make observation</p>

<pre><code>// any machine
$ kubectl exec -it exec-test-nginx-6558988d5-fgxgg -- sh
# sleep 5000
</code></pre></li>

<li><p>We can observe the kubectl process (pid=8507 in this case)</p>

<pre><code>// any machine
$ ps -ef |grep kubectl
501  8507  8409   0  7:19PM ttys000    0:00.13 kubectl exec -it exec-test-nginx-6558988d5-fgxgg -- sh
</code></pre></li>

<li><p>When we check network activities of the process, we can see that it has some connections to api-server (192.168.205.10.6443)</p>

<pre><code>// any machine
$ netstat -atnv |grep 8507
tcp4       0      0  192.168.205.1.51673    192.168.205.10.6443    ESTABLISHED 131072 131768   8507      0 0x0102 0x00000020
tcp4       0      0  192.168.205.1.51672    192.168.205.10.6443    ESTABLISHED 131072 131768   8507      0 0x0102 0x00000028
</code></pre></li>

<li><p>Let&rsquo;s check the code. kubectl creates a POST request with subresource <code>exec</code> and sends a rest request.
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/staging/src/k8s.io/kubectl/pkg/cmd/exec/exec.go?slice=344:359"></script></p></li>
</ul>

<p><img src="/img/kubectl-exec/rest-request.png"  title="rest-request"/></p>

<p><br></p>

<h3 id="2-activities-in-master-node">2. Activities in Master Node</h3>

<ul>
<li><p>We can observe the request in api-server side as well.</p>

<pre><code>handler.go:143] kube-apiserver: POST &quot;/api/v1/namespaces/default/pods/exec-test-nginx-6558988d5-fgxgg/exec&quot; satisfied by gorestful with webservice /api/v1
upgradeaware.go:261] Connecting to backend proxy (intercepting redirects) https://192.168.205.11:10250/exec/default/exec-test-nginx-6558988d5-fgxgg/exec-test-nginx?command=sh&amp;input=1&amp;output=1&amp;tty=1
Headers: map[Connection:[Upgrade] Content-Length:[0] Upgrade:[SPDY/3.1] User-Agent:[kubectl/v1.12.10 (darwin/amd64) kubernetes/e3c1340] X-Forwarded-For:[192.168.205.1] X-Stream-Protocol-Version:[v4.channel.k8s.io v3.channel.k8s.io v2.channel.k8s.io channel.k8s.io]]
</code></pre>

<blockquote>
<p>Notice that the http request includes a protocol upgrade request. <a href="https://www.wikiwand.com/en/SPDY">SPDY</a> allows for separate stdin/stdout/stderr/spdy-error &ldquo;streams&rdquo; to be multiplexed over a single TCP connection.</p>
</blockquote></li>

<li><p>Api server receives the request and binds it into a <code>PodExecOptions</code>
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/pkg/apis/core/types.go?slice=4124:4147"></script></p></li>

<li><p>To be able to take necessary actions, api-server needs to know which location it should contact.
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/pkg/registry/core/pod/strategy.go?slice=455:467"></script><br></p>

<p>Of course the endpoint is derived from node info.
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/pkg/registry/core/pod/strategy.go?slice=504:510"></script><br></p>

<p>GOTCHA! KUBELET HAS A PORT (<code>node.Status.DaemonEndpoints.KubeletEndpoint.Port</code>) TO WHICH API-SERVER CAN CONNECT.
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/pkg/kubelet/client/kubelet_client.go?slice=180:206"></script><br></p>

<blockquote>
<p><a href="https://kubernetes.io/docs/concepts/architecture/master-node-communication/#apiserver-to-kubelet">Master-Node Communication &gt; Master to Cluster &gt; apiserver to kubelet</a></p>

<p>These connections terminate at the kubelet’s HTTPS endpoint. By default, the apiserver does not verify the kubelet’s serving certificate, which makes the connection subject to man-in-the-middle attacks, and <strong><em>unsafe</em></strong> to run over untrusted and/or public networks.</p>
</blockquote></li>

<li><p>Now, api server knows the endpoint and it opens a connections.
<script src="https://gist-it.appspot.com/http://github.com/kubernetes/kubernetes/blob/a1f1f0b599e961a5c59b02c349c0ed818b1851a5/pkg/registry/core/pod/rest/subresources.go?slice=132:144"></script><br></p></li>

<li><p>Let&rsquo;s check what is going on the master node.</p></li>
</ul>

<p>First, learn the ip of the worker node. It is <code>192.168.205.11</code> in this case.</p>

<pre><code>// any machine
$ kubectl get nodes k8s-node-1 -o wide
NAME         STATUS   ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME
k8s-node-1   Ready    &lt;none&gt;   9h    v1.15.3   192.168.205.11   &lt;none&gt;        Ubuntu 16.04.6 LTS   4.4.0-159-generic   docker://17.3.3
</code></pre>

<p>Then get the kubelet port. It is <code>10250</code> in this case.</p>

<pre><code>// any machine
$ kubectl get nodes k8s-node-1 -o jsonpath='{.status.daemonEndpoints.kubeletEndpoint}'
map[Port:10250]
</code></pre>

<p>Then check the network. Is there a connection to worker node(192.168.205.11)? THE CONNECTİON IS THERE. When I kill the exec process, it disappears so I know it is set by api-server because of my exec command.</p>

<pre><code>// master node
$ netstat -atn |grep 192.168.205.11
tcp        0      0 192.168.205.10:37870    192.168.205.11:10250    ESTABLISHED
...
</code></pre>

<p><img src="/img/kubectl-exec/api-server-to-kubelet.png"  title="api-server-to-kubelet"/></p>

<ul>
<li>Now the connection between kubectl and api-server is still open and there is another connection between api-server and kubelet.</li>
</ul>

<p><br><br></p>

<h3 id="3-activities-in-worker-node">3. Activities in Worker Node</h3>

<ul>
<li>Let&rsquo;s continue by connecting to the worker node and checking what is going on the worker node.</li>
</ul>

<p>First, we can observe the connection here as well. The second line. <code>192.168.205.10</code> is the IP of master node.</p>

<pre><code>  // worker node
  $ netstat -atn |grep 10250
  tcp6       0      0 :::10250                :::*                    LISTEN
  tcp6       0      0 192.168.205.11:10250    192.168.205.10:37870    ESTABLISHED
</code></pre>

<p>What about our sleep command? HOORAYYYY!! OUR COMMAND IS THERE!!!!</p>

<pre><code>  // worker node
  $ ps -afx
  ...
  31463 ?        Sl     0:00      \_ docker-containerd-shim 7d974065bbb3107074ce31c51f5ef40aea8dcd535ae11a7b8f2dd180b8ed583a /var/run/docker/libcontainerd/7d974065bbb3107074ce31c51
  31478 pts/0    Ss     0:00          \_ sh
  31485 pts/0    S+     0:00              \_ sleep 5000
  ...
</code></pre>

<ul>
<li><p>Wait! How did kubelet do it?</p></li>

<li><p>kubelet has a daemon which serves an api over a port for api-server requests.
<script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/streaming/server.go?slice=41:60"></script><br></p></li>

<li><p>kubelet computes a response endpoint for exec requests.
<script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/streaming/server.go?slice=177:190"></script><br></p></li>
</ul>

<p>Don&rsquo;t confuse. It doesn&rsquo;t return the result of the command. It returns an endpoint for communication.
<script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.pb.go?slice=4533:4540"></script><br></p>

<p>kubelet implements <code>RuntimeServiceClient</code> interface which is part of Container Runtime Interface.
  <script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.pb.go?slice=7157:7229"></script><br></p>

<p>It just uses gRPC to invoke a method through Container Runtime Interface.
  <script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.pb.go?slice=7229:7233"></script><br></p>

<p><script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.pb.go?slice=7372:7381"></script><br></p>

<p>Container Runtime is responsible to implement <code>RuntimeServiceServer</code>
  <script src="https://gist-it.appspot.com/https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1alpha2/api.pb.go?slice=7436:7508"></script><br></p>

<p><img src="/img/kubectl-exec/kubelet-to-container-runtime.png"  title="kubelet-to-container-runtime"/></p>

<ul>
<li>If it is so, we need to observe a connection between kubelet and container runtime. Right? Let&rsquo;s check.</li>
</ul>

<p>Run this command before and after running exec command and check the diff. This one is the diff in my case.</p>

<pre><code>// worker node
$ ss -a -p |grep kubelet
...
u_str  ESTAB      0      0       * 157937                * 157387                users:((&quot;kubelet&quot;,pid=5714,fd=33))
...
</code></pre>

<p>Hımmm. There is a new connection via unix sockets between kubelet(pid=5714) and something. Who can be? YES. IT IS DOCKER(pid=1186).</p>

<pre><code>// worker node
$ ss -a -p |grep 157387
...
u_str  ESTAB      0      0       * 157937                * 157387                users:((&quot;kubelet&quot;,pid=5714,fd=33))
u_str  ESTAB      0      0      /var/run/docker.sock 157387                * 157937                users:((&quot;dockerd&quot;,pid=1186,fd=14))
...
</code></pre>

<p>Remember. This is the docker daemon process(pid=1186) which runs our command.</p>

<pre><code>// worker node.
$ ps -afx
...
 1186 ?        Ssl    0:55 /usr/bin/dockerd -H fd://
17784 ?        Sl     0:00      \_ docker-containerd-shim 53a0a08547b2f95986402d7f3b3e78702516244df049ba6c5aa012e81264aa3c /var/run/docker/libcontainerd/53a0a08547b2f95986402d7f3
17801 pts/2    Ss     0:00          \_ sh
17827 pts/2    S+     0:00              \_ sleep 5000
...
</code></pre>

<h3 id="4-activities-in-container-runtime">4. Activities in Container Runtime</h3>

<ul>
<li>Let&rsquo;s check cri-o&rsquo;s source code to understand how it can happen. The logic is similar in docker.</li>
</ul>

<p>It has a server which implements RuntimeServiceServer.
  <script src="https://gist-it.appspot.com/https://github.com/cri-o/cri-o/blob/master/server/server.go?slice=60:82"></script><br></p>

<p><script src="https://gist-it.appspot.com/https://github.com/cri-o/cri-o/blob/master/server/container_exec.go?slice=13:28"></script><br></p>

<p>At the end of the chain, container runtime executes the command in the worker node.
  <script src="https://gist-it.appspot.com/https://github.com/cri-o/cri-o/blob/master/internal/oci/runtime_oci.go?slice=292:342"></script><br></p>

<p><img src="/img/kubectl-exec/container-runtime-to-kernel.png"  title="container-runtime-to-kernel"/></p>

<p>Finally, kernel executes commands.
<img src="/img/kubectl-exec/kernel-puts.png"  title="kernel-puts"/></p>

<p><br><br></p>

<h2 id="reminders">Reminders</h2>

<ul>
<li>api-server can also initialize a connection to kubelet.</li>
<li>These connections persist until the interactive exec ends.

<ul>
<li>Connection between kubectl and api-server</li>
<li>Connection between api-server and kubelet</li>
<li>Connection between kubelet and container runtime</li>
</ul></li>
<li>kubectl or api-server cannot run anything in the worker nodes. kubelet can run but it also interacts with container runtime for this kind of actions.</li>
</ul>

<p><br><br></p>

<h2 id="resources">Resources</h2>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/kubernetes-dev/Cjia36v39vM">https://groups.google.com/forum/#!topic/kubernetes-dev/Cjia36v39vM</a></li>
<li><a href="https://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706">https://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706</a></li>
<li><a href="https://serverfault.com/questions/252723/how-to-find-other-end-of-unix-socket-connection">https://serverfault.com/questions/252723/how-to-find-other-end-of-unix-socket-connection</a></li>
</ul>
  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "erkanerol-github-io";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "erkanerol-github-io";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


 <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58713be9ad6e45ec"></script> 

<script src="https://erkanerol.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>

