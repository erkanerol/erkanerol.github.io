<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yazılım on Blog</title>
    <link>https://erkanerol.github.io/categories/yaz%C4%B1l%C4%B1m/</link>
    <description>Recent content in Yazılım on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr-tr</language>
    <lastBuildDate>Sun, 28 Aug 2016 16:15:53 +0300</lastBuildDate>
    <atom:link href="https://erkanerol.github.io/categories/yaz%C4%B1l%C4%B1m/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>KISS Prensibi</title>
      <link>https://erkanerol.github.io/post/kiss/</link>
      <pubDate>Sun, 28 Aug 2016 16:15:53 +0300</pubDate>
      
      <guid>https://erkanerol.github.io/post/kiss/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Basitlik nihai karmaşıklıktır.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/Simplicity.jpg&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;programlama-prensibi:420e591348e6c9d5196d6c45959f9c13&#34;&gt;Programlama Prensibi&lt;/h2&gt;

&lt;p&gt;KISS&lt;/p&gt;

&lt;h2 id=&#34;açılımlar:420e591348e6c9d5196d6c45959f9c13&#34;&gt;Açılımlar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Keep It Simple, Stupid&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Keep it Simple, Silly&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Keep It Short and Simple&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Keep It Simple and Straightforward&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Keep It Small and Simple&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;açıklama:420e591348e6c9d5196d6c45959f9c13&#34;&gt;Açıklama&lt;/h2&gt;

&lt;p&gt;KISS, basitlik için çabalamayı öneren bir prensiptir. 1960&amp;rsquo;lı yıllarda Amerikan donanmasında ilk olarak ifade edilen bu prensip günümüzde en önemli programlama prensiplerinden biridir. Bir problemi çözerken olabilecek en basit ve yalın çözümü seçmeyi önerir. Hatta o kadar basit olmalıdır ki ilk bakışta &amp;ldquo;Bunu bir aptal bile yapar ve anlar&amp;rdquo; demeliyiz.&lt;/p&gt;

&lt;p&gt;KISS, karmaşık çözümlerin daha &amp;ldquo;zekice&amp;rdquo;  çözümler olduğu fikrini reddeder. Çoğu mühendis/yazılımcı karmaşık çözümler bularak, karmaşık yapılar inşa ederek &amp;ldquo;zekice&amp;rdquo; işler yaptığını düşünür. Dışarıdan bakan bir insan ne kadar zor anlar ise o kadar artı değer ürettiğini sanır. Ancak zor olan basitleştirmektir. Yazılım süreçlerinde kod/yazılım mimarisi zaten zaman içinde büyüme ve karmaşıklaşma eğilimindedir. Önemli ve zor olan istenen işlevselliği asgari karmaşıklık düzeyinde sağlayabilmektir.&lt;/p&gt;

&lt;p&gt;Basit çözümler daha iyidir çünkü:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Basit çözümlerin uygulanması daha kolaydır.&lt;/li&gt;
&lt;li&gt;Basit çözümler hataya daha az açıktır.&lt;/li&gt;
&lt;li&gt;Basit çözümlerin bakımını yapmak daha kolaydır. Zaman tasarrufu sağlar.&lt;/li&gt;
&lt;li&gt;Basit çözümler kolay değiştirilebilir. Çevik olma açısından gereklidir.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;yöntemler:420e591348e6c9d5196d6c45959f9c13&#34;&gt;Yöntemler&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Zekanızı kodun karmaşıklığı üzerinden göstemeyin.&lt;/li&gt;
&lt;li&gt;Ufak çaplı performans kazançları için basit çözümler yerine karmaşık çözümleri tercih etmeyin.&lt;/li&gt;
&lt;li&gt;Problemleri alt problemlere ayırın. Alt problemleri az parametreli, kısa methodlar ile çözün.&lt;/li&gt;
&lt;li&gt;İstisnai durumları çok fazla düşünüp yapıyı karmaşıklaştırmayın.&lt;/li&gt;
&lt;li&gt;Geleceğin problemlerini bugünden çözmeye çalışmayın. (bkz: YAGNI)&lt;/li&gt;
&lt;li&gt;Kod silmekten çekinmeyin. En iyi kod en kısa koddur.&lt;/li&gt;
&lt;li&gt;Kodu yeniden düzenlemekten çekinmeyin. IDE&amp;rsquo;lerin de yardımıyla kodunuzu sık sık bölüp, sadeleştirin.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;kaynakça:420e591348e6c9d5196d6c45959f9c13&#34;&gt;Kaynakça&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://principles-wiki.net/principles:keep_it_simple_stupid&#34;&gt;http://principles-wiki.net/principles:keep_it_simple_stupid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/KISS_principle&#34;&gt;https://en.wikipedia.org/wiki/KISS_principle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://people.apache.org/~fhanik/kiss.html&#34;&gt;https://people.apache.org/~fhanik/kiss.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pratikprogramci.com/2014/06/01/en-basit-cozumu-olusturma-yetisi-nasil-kazanilir/&#34;&gt;http://www.pratikprogramci.com/2014/06/01/en-basit-cozumu-olusturma-yetisi-nasil-kazanilir/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Çıraklık Şablonları:  Hevesli Yazılım Ustasının Rehberi</title>
      <link>https://erkanerol.github.io/post/hevesli-yazilimcinin-rehberi/</link>
      <pubDate>Sun, 28 Aug 2016 15:56:13 +0300</pubDate>
      
      <guid>https://erkanerol.github.io/post/hevesli-yazilimcinin-rehberi/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;So, why this book now? Well, we’ve overloaded our profession with resources. There is more information available about our revolution than any one person can absorb. Still, some people manage to do it. They internalize all the advice available to them and always seem to have it close at hand. How do they do achieve that level of mastery? This book is full of patterns for mastering our complex field. Mastering is more than just knowing. It is knowing in a way that lightens your load.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;/br&gt;
TL;DR Şu kitabı her yazılımcının okuması gerektiğine inanıyorum ve şiddetle tavsiye ediyorum.
&lt;br&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/apprenticeship-cover.png&#34; title=&#34;Apprenticeship Patterns&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;tanıtım:c384b087910c43172fdcea43b3e304eb&#34;&gt;Tanıtım&lt;/h2&gt;

&lt;p&gt;Benim gözümde yazılımcılar ikiye ayrılıyor.
1. Para karşılığı bir süre kod yazan ve 40 yaşında kod yazmak istemeyenler.
+Para vermeselerde kod yazacak olan ve 40 yaşında bile kod yazmaktan kopmak istemeyenler.&lt;/p&gt;

&lt;p&gt;Bu kitap 2. kategori yazılımcı olmak isteyen çıraklar için bire bir. Meslek hayatının belirli dönemlerinde, belirli durumlarda yapılması gerekenlere dair tavsiyeler içeriyor. Bir çok yazılımcının tecrübelerinden yola çıkarak hazırlanan bu kitabın içinde bir çok şablon bulunuyor.&lt;/p&gt;

&lt;p&gt;Örnek olması açısında &amp;ldquo;Find Mentors&amp;rdquo; isimli şablonun özetini çıkardım:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Context:  Yürüdüğünüz yoldan daha önce geçenlerin olduğunu farkettiniz ve yolunuzu aramak için çok fazla zaman kaybediyorsunuz.&lt;/li&gt;
&lt;li&gt;Problem: Yürüdüğünüz yolda tek başınasınız ve önünüzü göremiyorsunuz. Yardıma ve rehberliğe ihtiyacınız var.&lt;/li&gt;
&lt;li&gt;Solution: Size çıraklığa kabul edecek ustalar bulun ve mentörünüz olmalarını isteyin.&lt;/li&gt;
&lt;li&gt;Action: Bir aracın, kütüphanenin veya topluluğun mail grubuna katılın. Bir süre pusuya yatın ve gözlemleyin. Yeteri derecede olaylara hakim olduktan sonra etkinliklerine katılın ve size mentörlük edebileceğini düşündüğünüz ustalardan &amp;ldquo;informal&amp;rdquo; mentörlük talep edin.&lt;/li&gt;
&lt;li&gt;See Also: &amp;ldquo;The Deep End&amp;rdquo; ve &amp;ldquo;The Long Road&amp;rdquo; isimli şablonlara da bakabilirsiniz.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;kitapta-bulunan-bütün-şablonlar:c384b087910c43172fdcea43b3e304eb&#34;&gt;Kitapta Bulunan Bütün Şablonlar&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/apprenticeship-patterns.png&#34; title=&#34;Apprenticeship Patterns&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;kişisel-yorumlarım:c384b087910c43172fdcea43b3e304eb&#34;&gt;Kişisel Yorumlarım&lt;/h2&gt;

&lt;p&gt;Ben kitaptaki bir çok şablonun benim durumuma uyduğunu gördüm ve çözüm önerilerini çok mantıklı buldum. Elimden geldiğince uygulamaya çalışacağım. Bu kitap aslında sadece belirli durumlara ilişkin yapılacaklar listesi değil. Kitabın tamamını okuduğunuzda yazılım alanında nasıl iyi bir yazılımcı olunabileceğine dair bir fikriniz oluyor. Mesleki gelişimin usûl esaslarını tanımlıyor ki usûlü esastan her daim önde tutan biri olarak ( bkz: usûl esasa mukaddemdir) benim en sevdiğim kısmı bu oldu. Yani kitap size şu kitapları okuyun demiyor, hangi kitapları okumanız gerektiğini nasıl anlayacağınızı anlatıyor. Yazılım geliştirmenin sadece bir dil/framework/kütüphane/araç bilmek olmadığını, işin ciddi bir felsefesi olduğunu anlamak açısından da oldukça faydalı. Bu arada bunları bilmenin ne kadar önemli olduğuna dair pek çok şablon var. Öyle kuru felsefeyle kalma diyor yani :) Benim yorumlamam bu kadar. Aşağıda altını çizdiğim bazı yerler var.&lt;/p&gt;

&lt;p&gt;Paylaşım linkleri aşağıda mevcuttur. Bu kitap çok önemli. Elden ele yayalım :)&lt;/p&gt;

&lt;h2 id=&#34;alıntılarım-spoiler:c384b087910c43172fdcea43b3e304eb&#34;&gt;Alıntılarım (SPOILER!!!)&lt;/h2&gt;

&lt;p&gt;Apprentices are people who are willing to take on a junior role that maximizes their learning opportunities, as opposed to people who try to climb as quickly as they can into roles that maximize their financial opportunities. In my experience, if the apprentice has talent and the right attitude, their financial success will inevitably follow their learning success.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Failure is inevitable. It happens to everybody sooner or later. In fact, someone who has never failed at anything has either avoided pushing at the boundaries of their abilities or has learned to overlook their own mistakes.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Working with masters is the best way to learn a craft.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;“I want to change the way people think about programming,” Kent said. I agreed. We both wanted to reverse what we thought had been a wrong turn in the progress of our industry. And, amazingly, we did it.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Humility is one of the foundations of a successful apprenticeship. Combined with ambition, humility will help keep you focused and progressing in the right direction.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;This book is written for software apprentices—for people who have had a taste of developing software and want to take it further, but need some guidance.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;An apprenticeship is a season in your career when your focus is more on your own growth than almost anything else.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;There are many other books we would recommend for people in those roles, but this book is for people at the beginning of the journey.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The strongest patterns are the ones that are applied productively over and over again.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;All the advice that has come out of our revolution does not help much until it becomes second nature. The craftsmanship movement in software recognizes that making this stuff second nature isn’t, well, second nature. These patterns are a welcome contribution to this progression.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;He who knows not and knows not that he knows not, is a fool — shun him!
He who knows not and knows that he knows not, is unlearned — teach him!
He who knows and knows not that he knows, is asleep — awaken him!
He who knows and knows that he knows, is enlightened — follow him!&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A pattern is a named description of a recurring solution to a problem in a given context.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Patterns are meant to be open to modification to fit your circumstances rather than mechanically applied.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;As with all pattern languages, you should be careful not to overuse these patterns. Don’t look for excuses to use every single pattern, but instead pick and choose the most appropriate set for your situation.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The journey discussed here starts with “Hello world!”, but where does it end? Far too often, it ends with a promotion to middle management.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The journey discussed here starts with “Hello world!”, but where does it end? Far too often, it ends with a promotion to middle management. Too many talented people thoughtlessly take that promotion and find themselves just a few years later in jobs they don’t enjoy and yearning for retirement. But for those who have a knack for developing software and enjoy the learning process, software development is a career that can last a lifetime, and it can be a great ride.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;For any programmer proficient in his first language, it’s always a temptation to fall back to the standards and idioms of your native language when you’re learning a new language.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Our goal here is not simply to hand people a rule book, but to give them the ability to create new practices for new contexts, which in turn drives the discipline of software development forward.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;An attachment to Carol Dweck’s research, which calls for a “growth mindset.” This entails a belief that you can be better and everything can be improved if you’re prepared to work at it. In her words, “effort is what makes you smart or talented” (Mindset, p. 16), and failure is merely an incentive to try a different approach next time. It is the opposite of the belief that we’re all born with a given amount of talent, and that failure is an indication that you don’t have enough of it.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A need to always be adapting and changing based on the feedback you get from the world around you.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A desire to be pragmatic rather than dogmatic.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A belief that it is better to share what we know than to create scarcity by hoarding it.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A willingness to experiment and be proven wrong. This means we try stuff. We fail. Then we use the lessons from that failure in the next experiment.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A dedication to what psychologists call an internal locus of control.[6] This involves taking control of and responsibility for our destinies rather than just waiting for someone else to give us the answers.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Instead, we think that a useful system should be able to identify and absorb the best ideas from all elements of the software development community.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;“I guess it basically means having the attitude that there’s always a better/smarter/faster way to do what you just did and what you’re currently doing. Apprenticeship is the state/process of evolving and looking for better ways and finding people, companies and situations that force you to learn those better/smarter/faster ways.”&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;“It is not an internal quantity that is fed by easy successes and diminished by failures&amp;hellip;. It is not something we give to people by telling them about their high intelligence. It is something we equip them to get for themselves—by teaching them to value learning over the appearance of smartness, to relish challenge and to use errors as routes to mastery”&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;you must learn to grow yourself, to learn how you learn.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;At some point, an apprentice is approached by a master or a journeyman and told that her work and her role in the community are that of a journeyman. In such a case, the apprentice had previously begun taking on more responsibilities, and like a “boiled frog” had made a gradual but not discrete transition from one state to another. That transition may take longer for some people than for others. For some, the transition may take longer than their professional careers.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The journeyman’s responsibilities are wider than those of an apprentice. As such his failures can do more harm. Some of the patterns we will discuss are not appropriate for a journeyman, precisely because he has a greater responsibility to others who may see him as a mentor.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;They might be facing overbearing and/or incompetent managers, de-motivated coworkers, impossible deadlines, and work environments that treat novice developers like workhorses, storing them in small, rectangular stalls with a PC and a crippled Internet connection.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The more experience you already have, the more effort you will need to put into “emptying your cup,” clearing your mind of bad habits, setting aside the pride you have in your skills, and opening yourself up to the different, often counterintuitive, approaches of your more experienced colleagues.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;One of the fundamental ways to improve the experience of learning your first language is to have an actual problem to solve.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;It is possible to learn a language on your own, but it takes a long time to learn the spirit of a language unless you interact with experts.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;One danger of digging deep into your first language is getting stuck. It likely will remain with you throughout your career as your native tongue.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Apprentices comfortable with an object-oriented language should explore a functional programming language. Apprentices comfortable with dynamic typing should explore static typing. Apprentices comfortable with server-side programming should explore user interface design.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;You shouldn’t be wedded to any particular technology, but have a broad enough background and experience base to allow you to choose good solutions in particular situations.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;never stopping to think that the freedom to be foolish might well be one of the keys to the genius’s success.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Find an opportunity to unlearn something. Ideally, this would be something that forces you to put aside your previous experience.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Ask that person to explain some of the misconceptions that people from your particular background usually have about their community.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Despite (and because of!) your inexperience, you bring some unique attributes to your team, including an infectious enthusiasm. Do not allow anyone to dampen your excitement for the craft—it is a precious commodity and will accelerate your learning.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;They either repress their enthusiasm altogether, or allow it to manifest only outside of their day jobs.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Comprehension can be increased if more levels of experience are connected, as when newcomers who take nothing for granted interrelate more often with old-timers who think they have seen it all.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Craftsmen learn from the apprentices, even as the apprentices learn from them. Enthusiastic beginners not only renew the craftsmen, but also challenge the craftsmen by bringing in new ideas from the outside. A well chosen apprentice can make even a master craftsman more productive.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Collect the CVs of people whose skills you respect.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;According to research by the social psychologist Carol Dweck, the need to appear competent is ingrained into people of most industrialized societies.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Software craftsmen build their reputations through strong relationships with their clients and colleagues.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Expertise is a by-product of the long road we’re all on, but it is not the destination. Over the course of their journey, craftsmen will work with countless technologies and domains.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;However, as an apprentice with aspirations to mastery, you need to be willing to Expose Your Ignorance as well.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Remember that learning in public is one of the ways in which an apprentice begins the transition to journeyman. It’s a small step from learning where people can see you to teaching.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;One of the distinguishing facets of the craft approach is a willingness to put the wider interests of your community before your own, rather than using the team and the client to further your personal growth.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;This new knowledge you have may reveal gaps you hadn’t noticed before; don’t forget to add these things to your list.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;It’s your responsibility to offset the risks of this approach by Finding Mentors and Kindred Spirits who can provide help when you need it.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Dave saw that although these exceptional people were miles ahead of him, they were all walking the same road.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;you should keep in mind the expectation that you will be a working software developer even when you are middle-aged.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;And rather than counting the days to retirement, the craftsman will willingly and joyfully work into her final decades.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Imagine that 40 years from now you are asked to write a short description of your professional history and the biggest influences on your path. Use the output from that thought experiment to help you plan your future career choices.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The things we build for customers can be beautiful, but must be useful.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;utility and beauty are not opposed, but interdependent.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Sometimes you will make the wrong trade-off, and fixing that mistake by rewriting the system from scratch may not be in the customer’s best interest. In those situations you will need to develop the ability to refactor and repair.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Anyone who has ever seen a programmer at work&amp;hellip;knows that programming itself, if the programmer is given the chance to do it his way, is the biggest motivation in programming.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;“I’d like to learn something new, but what I already know pays too well.”&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Your mother might think you deserve it, but impressive titles and responsibilities do not indicate that your apprenticeship is over.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;more time with your family or more money, or perhaps a new vocation has captured your attention.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;If and when they came back, we welcomed them with open arms because those experiences had given them new perspectives they could share. Sadly, conventional software organizations may not be so welcoming. They often see these detours as suspicious gaps in your career that you must justify. They will expect you to have a rationale that makes sense within their value system for why you left and why you’re coming back.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Be the lion’s tail rather than the fox’s head!&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Organizational cultures that encourage software craftsmanship are rare.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Andy Hunt, a highly respected software craftsman, has asserted numerous times that software development is composed of two primary activities: learning and communication&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;We would build on that idea and assert that the core theme of an apprenticeship is learning and the dominant trait of a successful apprentice is a demonstration of her learning abilities.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;The only people who achieve much are those who want knowledge so badly that they seek it while the conditions are still unfavourable.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Apprentices are thirsty for opportunities to replace their ignorance with skill.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;A good way to ensure you have interesting exercises to use in your practice sessions is to trawl through old books like Programming Pearls, More Programming Pearls, or Etudes for Programmers.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Over time, maintaining a wiki can teach you about HTTP, REST, parsing, web design, caching, full-text search, databases, and concurrency.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Your notebook, blog, or wiki should be a nursery, not a graveyard—lessons should be born from this record, rather than going there to die.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Early in your apprenticeship, develop the habit of regularly sharing the lessons you have learned. This may take the form of maintaining a blog or running “brown bag” sessions amongst your Kindred Spirits.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Furthermore, teaching is a powerful learning tool for the person doing the teaching, perhaps even more so than for the students. Thus the old saying “When one person teaches, two people learn.”&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Ingenuity is often misunderstood. It is not a matter of superior intelligence but of character. It demands more than anything a willingness to recognize failure, to not paper over the cracks, and to change. It arises from deliberate, even obsessive, reflection on failure and a constant searching for new solutions. —Atul Gawande, Better&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Be sure to intermingle classics with modern, pragmatic books and/or articles in your Reading List.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;This means that the next time someone talks to you about Representation State Transfer, better known as REST, you should take that as an excuse to read Roy Fielding’s PhD thesis in which he defined the concept.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Armed with your deeper knowledge of HTTP, try to implement a client and a server for RFC 707.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;We can guarantee that the tools you use as an apprentice will be obsolete by the time you become a journeyman. In time, all of your favorite tools will become junk. For your career to prosper, you must learn to acquire and abandon familiar tools with ease.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;When we say that something is a craft, one of the things we mean is that it is a discipline and a tradition that places a high value on skill. This includes acquiring, growing, and eventually transmitting that skill. We believe true mastery is shown in the effect you have on others by transmitting your superior skill.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;In software development, we don’t know exactly what constitutes mastery, but we do know what it isn’t.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;As an apprentice, you should aim to become better than your teachers. And if they are good teachers, they should try to help you achieve that goal.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;Mere genius is not mastery, but if a person is able to train others to equal or surpass her genius, then it becomes evident that person is a potential master.&lt;/p&gt;

&lt;p&gt;==========&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;there are no masters&amp;hellip;yet.&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>YAGNI Prensibi</title>
      <link>https://erkanerol.github.io/post/yagniprinciple/</link>
      <pubDate>Sat, 20 Aug 2016 22:46:50 +0300</pubDate>
      
      <guid>https://erkanerol.github.io/post/yagniprinciple/</guid>
      <description>

&lt;p&gt;Not: Bu yazı Martin Fowler&amp;rsquo;ın YAGNI yazısının özeti ve tercümesi niteliğindedir.&lt;/p&gt;

&lt;h2 id=&#34;programlama-prensibi:2db6997b7e4e28f4bef7f95c364f67ee&#34;&gt;Programlama Prensibi&lt;/h2&gt;

&lt;p&gt;YAGNI&lt;/p&gt;

&lt;h2 id=&#34;açılımlar:2db6997b7e4e28f4bef7f95c364f67ee&#34;&gt;Açılımlar&lt;/h2&gt;

&lt;p&gt;You Aren’t Gonna Need It
You Aint Gonna Need It&lt;/p&gt;

&lt;h2 id=&#34;açıklama:2db6997b7e4e28f4bef7f95c364f67ee&#34;&gt;Açıklama&lt;/h2&gt;

&lt;p&gt;YAGNI, Extreme programlamanın prensiplerinden biridir. Gelecekte lazım olacak düşüncesi ile bir takım özelliklerin geliştirilmemesi gerektiğini savunur. Şimdi bir örnek üzerinden bu prensibi anlamaya çalışalım.&lt;/p&gt;

&lt;p&gt;Diyelim ki projemize bir &amp;ldquo;oturum açma&amp;rdquo; özelliği ekliyoruz. O anda bizden istenen şey kullanıcıların kullanıcı adı ve şifreleri ile giriş yapabilmelerini sağlayan bir özellik. Fakat biz &amp;ldquo;ilerde lazım olur&amp;rdquo; düşüncesi ile facebook ile de oturum açılmasını sağlayabilecek şekilde geliştiriyoruz arka taraftaki methodlarımızı. İşte tam bu noktada YAGNI diyor ki &amp;ldquo;YAPMA&amp;rdquo;.  Peki neden?&lt;/p&gt;

&lt;p&gt;Yazılımcıların o an kullanmayacakları özellikleri geliştirmesinin en yaygın sebebi o özelliği o an geliştirmenin daha ucuz olacağını düşünmeleridir. Örneğimizden gidecek olursak geliştirici şöyle düşünür: &amp;ldquo;Şimdiden ben arka tarafta facebook entegrasyonunu yapayım. Yarın bir gün zaten istenecek bu benden. O zaman bu yazdıklarımı değiştirmem gerekmez.&amp;rdquo; Fakat bu özellik yazıldığı an itibari ile &amp;ldquo;varsayımsal özellik&amp;rdquo; kategorisindedir ve hiç bir zaman sizden talep edilmeyecek olabilir. Bu noktada bazıları bunun planlama olduğunu ve iyi analizler sonucu bu tip geliştirmeler yapılabileceğini iddia edebilir. Ne var ki gerçek hayat tecrübeleri bunun çok uzağındadır ve geliştiriciler yanlış öngördükleri varsayımsal özelliklerin geliştirme maliyetine katlanmak zorunda kalır. Bu özellik için harcanan analiz, programlama ve test etme süreleri boşa harcanmış olur.&lt;/p&gt;

&lt;p&gt;Diyelim ki biz doğru tahmin ettik ve o özellik gerçekten bize lazım olacaktı. Bu durumda bile bu varsayımsal özelliğin bize getirdiği ciddi maliyetler vardır. Birincisi biz gelecekte lazım olacağını düşündüğümüz bu özelliği yaparken bugün yapmamız gereken işlerin bir kısmını geciktiririz. Örneğin, oturum açma özelliğinden sonra bir arama özelliği eklememiz gerekiyordu ve biz facebook entegrasyonunu da yaptığımız için bu özellik 2 gün gecikti. Yani varsayımsal bu özellik bize gecikme maliyeti getirdi. Yapılan araştırmalara göre geliştirilen özelliklerin ancak &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;&amp;rsquo;ünün gerçekten faydalı olduğu da düşünülürse hali hazırda gerekli olan bir özelliği varsayımlar üzerine geciktirmek yeniden düşünülmesi gereken bir eylemdir.&lt;/p&gt;

&lt;p&gt;Doğru tahmin ettiğimiz durumdaki tek maliyet geciktirme maliyeti değildir. Taşıma maliyeti de en önemli sorunlardan biridir. Biz gelecekte işe yarayacağımız bu özelliğin kodunu projemizde taşımak zorunda kalırız. Bütün değişikliklerde kodun o kısmını da değiştirmemiz gerekir. O an hiç kullanmadığımız bu kod parçacığı hatalara sebep olabilir. Debug sırasında o kısmı da debug etmemiz gerekir. Özetle projeye eklenen her bir satır kodun bedellerini bu özellik için eklenen satırlar için de öderiz. Halbuki bu özelliği sonradan projeye ekleseydik bu süre içinde bu maliyete katlanmamız gerekmeyecekti.&lt;/p&gt;

&lt;p&gt;Şu ana kadar varsayımımızın doğru ve yanlış olduğu durumları ele aldık. Fakat daha gerçekçi olan olasılık tahminimizin doğru olması ama geliştirmenin tam doğru olmamasıdır. Yazılımcıların sürekli öğrendiğini ve gereksinimlerin sürekli değiştiğini düşünürsek eklediğimiz bu özelliği ilerleyen dönemlerde kullanmak istesek bile bazı değişikler yapmamız gerekir. Örneğin facabook API&amp;rsquo;da bir değişiklik yapmış olabilir. Kullandığımız kütüphaneden daha güzel bir kütüphane çıkmış olabilir ve onu değiştirmek isteyebiliriz. Bu durumlarda da bakım maliyetine katlanmak zorunda kalırız. Geliştirdiğimizi düşündüğümüz özelliği projeye gerçekten dahil etmek için fazladan efor harcarız.&lt;/p&gt;

&lt;p&gt;Aşağıda şu ana kadar anlattıklarımı özetleyen bir grafik mevcut.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/yagni.png&#34; title=&#34;YAGNI&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;ölçü:2db6997b7e4e28f4bef7f95c364f67ee&#34;&gt;Ölçü&lt;/h2&gt;

&lt;p&gt;YAGNI prensibinin ne zaman geçerli olduğu konusu biraz göreceli fakat kısaca şöyle denebilir: Varsaydığımız özelliğin büyüklüğü arttıkça YAGNI prensibinin önemi artar. 1-2 saatlik bir iş yapılacaksa ve bu ilerde bir kaç günlük bir geliştirmeyi karşılayacaksa bunda çok sakınca olmayabilir fakat bu süre uzadıkça riskleriniz artar.&lt;/p&gt;

&lt;p&gt;Ayrıca YAGNI kodun kolay değiştirilebilecek şekilde yazılmaması anlamına gelmez. Aksine YAGNI bir Extreme Programming prensibidir ve XP&amp;rsquo;nin en önemli pratiklerinden biri Refactoring&amp;rsquo;dir. XP kodun kolay değiştirilebilir olmasını öğütler. Bol bol refactoring yaparak kodumuzu temiz tuttuğumuzda, methodlarımızı parametrik yazdığımızda zaten özellikleri sonradan eklemek bize çok maliyet getirmez. Bu anlamda YAGNI esnek kod yazma ile çatışmaz, uyum içerisindedir.&lt;/p&gt;

&lt;h2 id=&#34;kaynakça:2db6997b7e4e28f4bef7f95c364f67ee&#34;&gt;Kaynakça&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://martinfowler.com/bliki/Yagni.html&#34;&gt;http://martinfowler.com/bliki/Yagni.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://webpro.github.io/programming-principles/#yagni&#34;&gt;http://webpro.github.io/programming-principles/#yagni&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.extremeprogramming.org/rules/early.html&#34;&gt;http://www.extremeprogramming.org/rules/early.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://c2.com/xp/YouArentGonnaNeedIt.html&#34;&gt;http://c2.com/xp/YouArentGonnaNeedIt.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Dry Prensibi</title>
      <link>https://erkanerol.github.io/post/dryprinciple/</link>
      <pubDate>Sat, 20 Aug 2016 20:23:06 +0300</pubDate>
      
      <guid>https://erkanerol.github.io/post/dryprinciple/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NOT: Bu yazı The Pragmatic Programmer kitabındaki &amp;ldquo;The Evils of Duplication&amp;rdquo; bölümünden yararlanılarak yazılmıştır.&lt;/p&gt;

&lt;h2 id=&#34;programlama-prensibi:d0614ac1fa1cc14179708291a9502c82&#34;&gt;Programlama Prensibi&lt;/h2&gt;

&lt;p&gt;DRY&lt;/p&gt;

&lt;p&gt;Keep It Dry&lt;/p&gt;

&lt;p&gt;Keep Things Dry&lt;/p&gt;

&lt;h2 id=&#34;açılımlar:d0614ac1fa1cc14179708291a9502c82&#34;&gt;Açılımlar&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t repeat yourself&lt;/p&gt;

&lt;h2 id=&#34;açıklama:d0614ac1fa1cc14179708291a9502c82&#34;&gt;Açıklama&lt;/h2&gt;

&lt;p&gt;DRY prensibi yazılımın en temel prensiplerinden biridir. &amp;ldquo;Kendini tekrar etme&amp;rdquo; anlamına gelen bu prensip kod tekrarlarından sakınılması gerektiğini savunur. The Pragmatic Programmer kitabında DRY olarak isimlendirilmiş ve genişçe açıklanmıştır.&lt;/p&gt;

&lt;p&gt;Programcılar olarak bizler bilgiyi toplar, organize eder, bakımını yapar ve programlarımızda kullanırız. Zaman zaman dökümanlar hazırlarız. Testlerde kontrol amaçlı kullanırız. Fakat maalesef bilgi durağan değildir, zaman içinde sıklıkla değişir. Bizler elimizdeki bilgiler her değiştiğinde yaptığımız işleri gözden geçirmek ve onları bu güncellemeye göre değiştirmek zorundayız.  Bu bakım sırasında bilginin sistem içindeki bütün gösterimlerini bulmamız gerekir. Eğer sistem içerisinde değişen bilgilerin bir çok yerde gösterimleri var ise bu bakım kabusa dönüşür. Bu nedenle yazılımın daha güvenilir olması, bakımının kolay yapılabilmesi ve anlaşılması adına şu prensibe ihtiyacımız vardır:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Her bir bilgi parçacığı sistem içinde tek, anlaşılabilir ve yetkilendirilmiş bir gösterime sahip olmalıdır.&amp;rdquo;
Aksi halde bir yerde değişiklik yaptığımızda diğer yerlerde de değişiklik yapmayı hatırlamamız gerekir ki bu gereklilik hatalara neden olabilir.  Şimdi bunu iki örnek ile açıklayalım.&lt;/p&gt;

&lt;p&gt;Birincisi çok basit bir kod tekrar örneği. [4]&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-js&#34;&gt;
// BAD
if ( eventfade.data( &#34;currently&#34; ) !== &#34;showing&#34; ) {
    eventfade.stop();
}
 
if ( eventhover.data( &#34;currently&#34; ) !== &#34;showing&#34; ) {
    eventhover.stop();
}
 
if ( spans.data( &#34;currently&#34; ) !== &#34;showing&#34; ) {
    spans.stop();
}
 
// GOOD!!
var elems = [ eventfade, eventhover, spans ];
 
$.each( elems, function( i, elem ) {
    if ( elem.data( &#34;currently&#34; ) !== &#34;showing&#34; ) {
        elem.stop();
    }
});
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Yukarıdaki örnekte bir kontrol ve method çağırma işlemi 3 element içinde ayrı ayrı yapılmış. Diyelim ki biz bu koşulda ikinci bir method çağırma ihtiyacı duyduk. Yapacağımız şey 3 if bloğunun içine de bu çağırma ifadesini eklemek olacaktı. Bu sayının 3 değilde 10 olduğunu düşündüğümüzde bunun hataya ne kadar açık olduğunu görebiliriz.  Halbuki ikinci şekildeki gibi yazılsaydı bir satırda değişikliğimizi yapabilirdik. Bu nedenle kodu başlangıçta ikinci şekildeki gibi yazmalıyız. Eğer elementlere özel değişik koşullar eklenirse refactoring yaparak kodu bölmeli ve yine tekrarlama olmadan işimizi halletmeliyiz.&lt;/p&gt;

&lt;p&gt;İkinci olarak daha güzel bir örnek vermek istiyorum. Diyelim ki bir CRUD uygulaması yazıyoruz. Uygulamada 3 tip kullanıcı var: yönetici, kayıtlı kullanıcı ve misafir kullanıcı. Uygulamada 4 tip varlık (entity) ve bunların web sayfaları var.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;
//BAD
HashMap&lt;String,String&gt; pages = new HashMap&lt;String, String&gt;();
pages.put(&#34;book&#34;,&#34;mybooks.xhtml&#34;);
pages.put(&#34;author&#34;,&#34;myauthors.xhtml&#34;);
pages.put(&#34;reader&#34;,&#34;myreaders.xhtml&#34;);
pages.put(&#34;library&#34;,&#34;mylibraries.xhtml&#34;);

HashMap&lt;String,String&gt; adminAuthority = new HashMap&lt;String,String&gt;();
adminAuthority.put(&#34;book&#34;,&#34;all&#34;);
adminAuthority.put(&#34;author&#34;,&#34;all&#34;);
adminAuthority.put(&#34;reader&#34;,&#34;all&#34;);
adminAuthority.put(&#34;library&#34;,&#34;all&#34;);

HashMap&lt;String,String&gt; registeredUserAuthority = new HashMap&lt;String,String&gt;();
registeredUserAuthority.put(&#34;book&#34;,&#34;create&#34;);
registeredUserAuthority.put(&#34;author&#34;,&#34;create&#34;);
registeredUserAuthority.put(&#34;reader&#34;,&#34;read&#34;);
registeredUserAuthority.put(&#34;library&#34;,&#34;read&#34;);

HashMap&lt;String,String&gt; guestUserAuthority = new HashMap&lt;String,String&gt;();
adminAuthority.put(&#34;book&#34;,&#34;read&#34;);
adminAuthority.put(&#34;author&#34;,&#34;read&#34;);
adminAuthority.put(&#34;reader&#34;,&#34;read&#34;);
adminAuthority.put(&#34;library&#34;,&#34;read&#34;);



//GOOD
public class MyEntity {
    String page;
    HashMap&lt;String,String&gt; authorities;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;İlk şekilde bir bilginin dörde ayrılıp 4 farklı yerde saklandığını görüyoruz. Bir varlığın web sayfası ve 3 kullanıcı için yetkileri 4 farklı yerde. Yeni bir varlık eklememiz gerektiğinde 4 yerde değişiklik yapmamız zorunlu. Halbuki ikinci şekildeki gibi bir nesne kullansak, uygulamanın her bileşeni bu bilgi içinden kendine lazım olan kısmı alır ve kullanır. Böylece bilginin bir gösterimi olur ki takibi ve bakımı çok daha kolay olur.&lt;/p&gt;

&lt;p&gt;DRY prensibinin açıklamasında sistem kelimesinin kullanılmasının bir anlamı vardır. Tekrarlamanın sadece kodda değil bütün bir sistemde olmaması gerektiğini ifade eder. Yorumlar, testler, dökümanlar vb. bu sisteme dahildir.&lt;/p&gt;

&lt;p&gt;Tipler, Nedenler ve Çözüm Önerileri&lt;/p&gt;

&lt;h3 id=&#34;1-zorla-tekrarlama:d0614ac1fa1cc14179708291a9502c82&#34;&gt;1. Zorla Tekrarlama&lt;/h3&gt;

&lt;p&gt;Bu tekrarlama tipinde geliştiriciler tekrarlama yapmaktan başka çarelerinin olmadığını düşünürler.&lt;/p&gt;

&lt;p&gt;a) Bilginin birden fazla gösteriminin zorunlu olması: Bazen yazılımın mimarisi tekrarlamayı sorunlu kılar. Örneğin, server-client yapısı kullandığımızda iki tarafta da aynı bilgiyi kullanmamız gerekir. Bu gibi durumlarda dilin metadata özelliklerini kullanarak kod üreten kodlar geliştirmeye, tekrarlamaları otomotik olarak üretmeye çalışmalıyız.
b) Kodun içinde dökümantasyon: Geliştiriciler zaman zaman iyi kodun çok yorum eklenen kod olduğunu düşünse de iyi kod çok yorum gerektirmez. Özellikle alt düzeylerde çok açık işlemleri yorumlamak tekrarlama olarak düşünülebilir. Bu nedenle sadece gerekli yerlerde yorumlar eklenmelidir.
c)Kod ve Dökümantasyon: Dökümanlar ve kod  çoğu zaman aynı bilginin farklı gösterimlerini içerir ve ikisinden birinde değişiklik yaptığımızda diğerinde de yapmamız gerekir. Bu tip durumlarda değişimleri otomatik olarak diğer tarafa yansıtacak otomasyonlar kullanmalıyız. Javadoc buna güzel bir örnektir.
d)Dil ile ilgili meseleler: Bazı diller tekrarlamayı zorunlu kılar. Aynı bilgiyi farklı yerlerde kullanmamızı bizden talep eder. C ve C++ dillerindeki başlık(header) dosyaları buna örnektir. Bu gibi durumlarla başa çıkmak kolay değildir. Dile özgü çözümleri araştırmamız ve tekrarlamadan kaynaklı sorunları nasıl hafifleteceğimizi bulmamız gerekir.&lt;/p&gt;

&lt;h3 id=&#34;2-yanlışlıkla-tekrarlama:d0614ac1fa1cc14179708291a9502c82&#34;&gt;2. Yanlışlıkla Tekrarlama&lt;/h3&gt;

&lt;p&gt;Bu tekrarlama tipinde geliştiriciler tekrarlama yaptığının farkında değildirler. Yukarıda verdiğimiz örnekler bu kategoride değerlendirilebilir. Yazılımın genel prensiplerine uyarak ve takım içinde birbirimizin kodlarını gözden geçirerek bu sorunu çözebiliriz.&lt;/p&gt;

&lt;h3 id=&#34;3-sabırsızlıktan-tekrarlama:d0614ac1fa1cc14179708291a9502c82&#34;&gt;3. Sabırsızlıktan Tekrarlama&lt;/h3&gt;

&lt;p&gt;Bu tekrarlama tipinde geliştiriciler tembellik eder ve tekrarlamayı daha kolay bulurlar. Bu tekrarlamaların kısa vadede zaman kazandırsa da uzun vadede büyük sorunlara yol açtığı açıktır. Bilinçlenme, disiplinli kod geliştirme ve takım içinde kodların gözden geçirilmesi ile çözülebilir. (Aptallığın lüzumu yok :D )&lt;/p&gt;

&lt;h3 id=&#34;4-geliştiriciler-arası-tekrarlama:d0614ac1fa1cc14179708291a9502c82&#34;&gt;4. Geliştiriciler Arası Tekrarlama&lt;/h3&gt;

&lt;p&gt;Bu tekrarlama tipinde farklı geliştiriciler bir bilgiyi farklı yerlerde tekrarlarlar. Geliştiriciler arasındaki iletişim yeterince kuvvetli olmadığında bu sorun ortaya çıkabilir. İletişimi kuvvetlendirerek, birbirimizin kodlarını gözden geçirerek bu sorunu çözebiliriz. Ayrıca yazılım mimarisinin hatalı olması da geliştiricileri buna zorlayabilir. Anlaşılabilir tasarım, iyi bir teknik lider, görevlerin iyi bir şekilde ayrıştırılması bu sorunun başlıca çözümlerindendir.&lt;/p&gt;

&lt;h3 id=&#34;kaynakça:d0614ac1fa1cc14179708291a9502c82&#34;&gt;Kaynakça&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Hunt, Andrew, and David Thomas. &amp;ldquo;7. The Evils of Duplication.&amp;rdquo; The Pragmatic Programmer: From Journeyman to Master. Reading, MA: Addison-Wesley, 2000. N. pag. Print.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kurumsaljava.com/2009/11/17/dry/&#34;&gt;http://www.kurumsaljava.com/2009/11/17/dry/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.jquery.com/code-organization/dont-repeat-yourself/&#34;&gt;https://learn.jquery.com/code-organization/dont-repeat-yourself/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Yazılım Mühendisi olmak veya Stackoverflow Google&#39;lamak</title>
      <link>https://erkanerol.github.io/post/yazilim-muhendisi-olmak-veya-stackoverflow-googlelamak/</link>
      <pubDate>Mon, 24 Aug 2015 20:40:00 +0200</pubDate>
      
      <guid>https://erkanerol.github.io/post/yazilim-muhendisi-olmak-veya-stackoverflow-googlelamak/</guid>
      <description>&lt;p&gt;Geçenlerde gördüğüm zaytung tarzı bir haber beni epey güldürmüştü ve hemen arkadaşlarımla paylaşmıştım. Haber şöyleydi: IEEE, bilgisayar programlama disiplininin bundan sonra resmi olarak &amp;ldquo;Stackoverflow google&amp;rsquo;lamak&amp;rdquo; olarak yeniden adlandırılmasına ilişkin şiddetli tavsiye içeren bir rapor yayınladı. Haber komik olmakla birlikte çok büyük bir gerçeğe işaret ediyor bana kalırsa. Bu yazıda bu konuya ilişkin bir kaç şeyden söz etmeye çalışacağım. (bkz: abstract)&lt;/p&gt;

&lt;p&gt;Bir aydan kısa bir süredir Java tabanlı web yazılımları geliştirmekle meşgulüm. Öncesinde pek bir şey bildiğim söylenemez. Uzun uzun projede kullanılan araçları öğrenme fırsatım da olmadı. Lazım oldukça kısa kısa bakıyorum. Gün içerisinde onlarca sorun ile karşılaşıyorum ve yine onlarca kez  sorunu Google&amp;rsquo;da aratıyorum. Google sağolsun yazdığım anahtar kelimelerden uygun sayfayı bulup önüme koyuyor. Soruyu bile okumadan sayfayı aşağı çekip cevaba bakıyorum hemen. Eğer yüksek oy almış bir cevap varsa soruya bakıyorum. Sorun benzerse çözümü deniyorum. Olursa ne ala. Olmazsa diğer sorulara ve önerilere geçiyorum. Aslında yaptığım iş tam olarak Google&amp;rsquo;lamak. Öyle sanıyorum ki Türkiye&amp;rsquo;deki meslektaşlarımın (hayatımda ilk kez kullandım bu kelimeyi, hoşuma gitti şu anda) önemli bir bölümü de işi böyle yürütüyor. Hatta &amp;ldquo;Stackoverflow kapansa Dünya genelindeki yazılım geliştirme hızı yarı yarıya azalır.&amp;rdquo; diye bir iddiam bile var. Özetle stackoverflow yazılımcılar için bulunmaz nimet. stackexchange.com&amp;rsquo;un içindeki diğer topluluklar da gittikçe gelişiyor ve çok faydalı. Bir göz atmanızı öneririm.&lt;/p&gt;

&lt;p&gt;FAKAT bir sorun var. Sadece çözümü kopyalamak hem bana çok bir şey öğretmiyor hem de içime sinmiyor. Fen lisesinde ve üniversitede hocalarımın ruhuma saldıkları soru sorma -neden?nasıl?niye öyle tasarlamışlar ki? şöyle yapsak nasıl olur acaba?- virüsü(!)  yakamı bırakmıyor. Ama verilen cevapları uzun uzun okumaya, anlamaya, anlamadığım yerleri ayrı ayrı aratıp en ince ayrıntısına kadar öğrenmeye kalksam yazılım geliştirme süreci fena halde yavaşlar. Zaten kimsenin öyle yaptığını sanmıyorum. Böyle şeyler biraz zamanla gelişiyor farkındayım. Ama böyle düşünürsem sanki hep cevap okuyan, soru soran tarafta kalıcakmışım gibi geliyor. Ben de bir süreden sonra soru cevaplayan tarafta olmak istiyorum. (Cevap demişken kapatıp açmayı denemenizi öneririm efendim ) Üretmeden tüketmek bana göre değil. (bkz: reklam kokan ifadeler)&lt;/p&gt;

&lt;p&gt;Ben şimdilik şöyle bir yol buldum. Çalışma sırasında önemli gördüğüm yerleri not alıyorum, boş bir vaktimde inceliyorum. Olaylara biraz daha vakıf olayım blog yazmaya da başlayacağım. Birine bir şeyi öğretmeye çalışmak çok öğretici oluyor gerçekten.Hem Türkçe kaynaklar maalesef çok yetersiz, belki bir katkımız olur. Özellikle yoğunlaştığım framework&amp;rsquo;lerin dökümanlarını okumayı,source kodları incelemeyi de planlıyorum. Ayrıca camianın nabzını tutmaya, önemli blogları keşfetmeye/takip etmeye çalışıyorum. Herşeyi öğrenmeye çalışıp kendimi yıpratmak niyetinde değilim ama buton nasıl eklenir olayıyla kendimi sınırlandırmak istemem. İşin felsefesine yönelik şeylere de bakıyorum. Hem yazılım geliştirmek stackoverflow&amp;rsquo;dan kod kopyalamaktan ibaret olsaydı o kadar kitap o kadar makale o kadar blog boşuna yazılmadı herhalde.&lt;/p&gt;

&lt;p&gt;Yazıyı şöyle bitireyim: Aşağıdaki fotoğraf bir süre konuşuldu. Whatsapp Türkiye&amp;rsquo;nin en büyük şirketlerinden (THY, Tüpraş, Turkcell) 3 tanesinin toplamından daha değerli imiş. &amp;ldquo;Bizim acil yazılım işine girmemiz lazım. Yazılımda çok para var.&amp;rdquo;  muhabbetleri çok döndü. Tabi herkes patronluğa talip kodu yazmaya niyetlenen yok. Fakat o uygulamalar öyle sürükle bırakla, kod kopyalamakla hemen yazılamıyor maalesef. Biz hızlı treni insanla test ederken &amp;ldquo;gavur&amp;rdquo; eğlence amaçlı bir uygulamayı bile çok sıkı test ediyor. Bir yandan da Türkiye&amp;rsquo;de bu işe para yatıran, şirket kuran insanlar kalifiye çalışan bulamamaktan şikayet ediyor. Eğer gerçekten kaliteli yazılımlar geliştirmek ciddi paralar kazanmak (kalite yeterli olmayabilir ama gerekli) istiyorsak, eğer arkadan takip etmeyi bırakmak istiyorsak stackoverflow&amp;rsquo;da soru cevaplayan adamlar lazım bize galiba. Şuna bile razıyım yahu: &amp;ldquo;It works for me&amp;rdquo; :D&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/stackoverflowlamak.jpg&#34; title=&#34;stackoverflowlamak&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Yeni yetme bir coder&amp;rsquo;ın &amp;ldquo;parlak&amp;rdquo; fikirlerini dinlediğiniz için teşekkür ederim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2 General/Ordu Problemi</title>
      <link>https://erkanerol.github.io/post/two-army-problem/</link>
      <pubDate>Mon, 24 Aug 2015 20:31:00 +0200</pubDate>
      
      <guid>https://erkanerol.github.io/post/two-army-problem/</guid>
      <description>

&lt;p&gt;Bu yazıda Two Generals&amp;rsquo; Problem ya da The Two Army Problem olarak anılan problemi anlatmaya çalışacağım.&lt;/p&gt;

&lt;p&gt;Ortada bir savaş var. A1 ve A2 orduları B ordusuna karşı savaşıyor fakat resimdeki gibi ayrı düşmüşler. Ancak elçiler vasıtası ile iletişim kurulabiliyor. Bu iki ordu aynı anda B ordusuna hücum etmek istiyor fakat kesin bir şekilde anlaşmaları lazım. Aksi halde yenilebilirler.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://erkanerol.github.io/img/two-army.png&#34; title=&#34;Two Army&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Problemimiz şu: Bu iki ordu elçiler göndererek bir mütabakata varabilirler mi? Anlaştıklarından %100 emin olabilirler mi?&lt;/p&gt;

&lt;p&gt;Şimdi senaryoları düşünelim.&lt;/p&gt;

&lt;h3 id=&#34;senaryo-1:eb974f5d6b427b1bb86ece6b1b1c05b9&#34;&gt;Senaryo 1&lt;/h3&gt;

&lt;p&gt;A1 ordusu taaruzun günü ve saatini elçi vasıtası ile A2 ordusuna iletmek istiyor. Bir elçi gönderiliyor. Elçi dönmüyor. O gün ve saat gelince A1 ordusu hücum eder mi? Etmez. Çünkü elçi yolda ölmüş olabilir ya da A2 ordusu kabul etmeyip elçiyi öldürmüş olabilir.&lt;/p&gt;

&lt;h3 id=&#34;senaryo-2:eb974f5d6b427b1bb86ece6b1b1c05b9&#34;&gt;Senaryo 2&lt;/h3&gt;

&lt;p&gt;Elçi A2 ordusuna isteği iletiyor. A2 ordusu kabul ediyor. Elçi bu haberi göndermek için geri yola çıkıyor. A2 ordusu belirtilen gün ve saat gelince hücum eder mi? Etmez. Çünkü elçi geri dönerken ölmüş olabilir. O zaman A1 ordusu hücum etmiycektir ve A2 ordusu yalnız kalacaktır. O nedenle A2 ordusu mesajın geri iletildiğinden emin olmalı.&lt;/p&gt;

&lt;h3 id=&#34;senaryo-3:eb974f5d6b427b1bb86ece6b1b1c05b9&#34;&gt;Senaryo 3&lt;/h3&gt;

&lt;p&gt;Elçi gidip teklifi A2&amp;rsquo;ye iletiyor. Kabul mesajını dönüp A1&amp;rsquo;e iletiyor. Sonra yeniden gidip A2 ordusuna kabul mesajının iletildiğini iletiyor. Fakat A1 ordusu bu durumda emin olamaz çünkü elçinin ikinci seferde de ulaştığından emin olmalı. Çünkü aksi halde A2 ordusu hücum etmiycektir.&lt;/p&gt;

&lt;h3 id=&#34;sonuç:eb974f5d6b427b1bb86ece6b1b1c05b9&#34;&gt;Sonuç&lt;/h3&gt;

&lt;p&gt;Senaryolarda da görüldüğü gibi elçinin tur sayısı ne kadar arttırılırsa arttırılsın iki taraf kesin bir şekilde emin olamaz.&lt;/p&gt;

&lt;h3 id=&#34;tcp-protokolü-ile-alakası:eb974f5d6b427b1bb86ece6b1b1c05b9&#34;&gt;TCP Protokolü ile alakası&lt;/h3&gt;

&lt;p&gt;TCP protokolünde bilgisayarların IP paketleri vasıtası ile bağlantılarının kapatılması konusunda anlaşmaya çalışmasında da aynı problem yaşanmakta. Sorun timeout kullanarak çözülüyor. Eğer karşı tarafın cevabı belirli bir süre içinde gelmezse bağlantı kapatılıyor.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>